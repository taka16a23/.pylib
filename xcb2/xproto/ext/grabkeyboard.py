#!/usr/bin/env python
# -*- coding: utf-8 -*-

# $Id: grabkeyboard.py 342 2015-07-24 05:07:32Z t1 $
# $Revision: 342 $
# $Date: 2015-07-24 14:07:32 +0900 (Fri, 24 Jul 2015) $
# $Author: t1 $
# $LastChangedBy: t1 $
# $LastChangedDate: 2015-07-24 14:07:32 +0900 (Fri, 24 Jul 2015) $

r"""grabkeyboard -- a parts of xcb2

GrabKeyboard

grab-window: WINDOW
owner-events: BOOL
pointer-mode, keyboard-mode: { Synchronous, Asynchronous}
time: TIMESTAMP or CurrentTime

status: { Success, AlreadyGrabbed, Frozen, InvalidTime, NotViewable}

Errors: Value, Window

This request actively grabs control of the keyboard. Further key events are
reported only to the grabbing client. This request overrides any active keyboard
grab by this client.

If owner-events is False, all generated key events are reported with respect to
grab-window. If owner-events is True and if a generated key event would normally
be reported to this client, it is reported normally. Otherwise, the event is
reported with respect to the grab-window. Both KeyPress and KeyRelease events
are always reported, independent of any event selection made by the client.

If keyboard-mode is Asynchronous, keyboard event processing continues
normally. If the keyboard is currently frozen by this client, then processing of
keyboard events is resumed. If keyboard-mode is Synchronous, the state of the
keyboard (as seen by means of the protocol) appears to freeze. No further
keyboard events are generated by the server until the grabbing client issues a
releasing AllowEvents request or until the keyboard grab is released. Actual
keyboard changes are not lost while the keyboard is frozen. They are simply
queued for later processing.

If pointer-mode is Asynchronous, pointer event processing is unaffected by
activation of the grab. If pointer-mode is Synchronous, the state of the pointer
(as seen by means of the protocol) appears to freeze. No further pointer events
are generated by the server until the grabbing client issues a releasing
AllowEvents request or until the keyboard grab is released. Actual pointer
changes are not lost while the pointer is frozen. They are simply queued for
later processing.

This request generates FocusIn and FocusOut events.

The request fails with status AlreadyGrabbed if the keyboard is actively grabbed
by some other client. The request fails with status Frozen if the keyboard is
frozen by an active grab of another client. The request fails with status
NotViewable if grab-window is not viewable. The request fails with status
InvalidTime if the specified time is earlier than the last-keyboard-grab time or
later than the current server time. Otherwise, the last-keyboard-grab time is
set to the specified time with CurrentTime replaced by the current server time.
"""
from cStringIO import StringIO as _StringIO
from struct import pack as _pack

from xcb2 import Request
from xcb2.xproto.ext.abstract import CoreMethodAbstract
from xcb2.xproto import GrabKeyboardCookie, GrabKeyboardReply
from xcb2.xproto import GrabMode


__all__ = ['GrabKeyboard', 'GrabKeyboardUnchecked', ]


class GrabKeyboardAbstract(CoreMethodAbstract):
    r"""SUMMARY
    """

    fmt = '=xB2xIIBB2x'
    code = 31

    _async = _pack('B', GrabMode.Async)
    _sync = _pack('B', GrabMode.Sync)

    def _getbinary(self, owner_events, grab_window, time, pointer_mode,
                keyboard_mode):
        buf = _StringIO()
        buf.write(_pack(self.fmt, owner_events, grab_window, time, pointer_mode,
                keyboard_mode))
        return buf.getvalue()

    def __call__(self, owner_events, grab_window, time, pointer_mode,
                keyboard_mode):
        """Request GrabKeyboard X protocol.

        @Arguments:
        - `owner_events`:
        - `grab_window`:
        - `time`:
        - `pointer_mode`:
        - `keyboard_mode`:

        @Return:
        VoidCookie

        @Error:
        BadValue, BadWindow
        """
        return self.request(
            self._getbinary(
                owner_events, grab_window, time, pointer_mode, keyboard_mode))

    def _get_async_binary(self, owner_events, grab_window, time):
        r"""SUMMARY

        _get_async_binary(owner_events, grab_window, time)

        @Arguments:
        - `owner_events`:
        - `grab_window`:
        - `time`:

        @Return:
        """
        buf = _StringIO()
        buf.write(_pack('=xB2xII', owner_events, grab_window, time))
        buf.write(self._async) # pointer_mode
        buf.write(self._async) # keyboard_mode
        buf.write(_pack('2x'))
        return buf.getvalue()

    def async(self, owner_events, grab_window, time):
        r"""SUMMARY

        async(owner_events, grab_window, time)

        @Arguments:
        - `owner_events`:
        - `grab_window`:
        - `time`:

        @Return:
        """
        return self.request(
            self._get_async_binary(owner_events, grab_window, time))


class GrabKeyboard(GrabKeyboardAbstract):
    r"""SUMMARY
    """

    def request(self, binary):
        r"""SUMMARY

        request(owner_events, grab_window, time, pointer_mode,
                keyboard_mode)

        @Arguments:

        @Return:
        """
        return self._connection.core.send_request(
            Request(binary, self.code, False, True),
            GrabKeyboardCookie(), GrabKeyboardReply)


class GrabKeyboardUnchecked(GrabKeyboardAbstract):
    r"""SUMMARY
    """

    def request(self, binary):
        r"""SUMMARY

        request(owner_events, grab_window, time, pointer_mode,
                keyboard_mode)

        @Arguments:

        @Return:
        """
        return self._connection.core.send_request(
            Request(binary, self.code, False, False),
            GrabKeyboardCookie(), GrabKeyboardReply)



# For Emacs
# Local Variables:
# coding: utf-8
# End:
# grabkeyboard.py ends here
